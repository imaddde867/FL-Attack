<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Federated Learning Gradient Inversion: Interactive Explorer</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%231f2636'/%3E%3Ctext y='55%25' x='50%25' font-size='34' fill='%23f5f6fa' text-anchor='middle'%3E%F0%9F%90%8E%3C/text%3E%3C/svg%3E" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f131c;
      --bg-card: #171d2a;
      --bg-panel: #1f2636;
      --border: #2e3548;
      --text: #f5f6fa;
      --muted: #c7cddf;
      --accent: #69a9ff;
      --accent-strong: #f5d742;
      --danger: #ff7676;
      font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      line-height: 1.4;
    }
    .page {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background: #0b0e15;
      padding: 18px 32px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
    }
    header h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: 0.02em;
    }
    header .meta {
      text-align: right;
      font-size: 14px;
      color: var(--muted);
    }
    header .key-finding {
      margin-top: 6px;
      font-size: 15px;
      color: var(--accent-strong);
    }
    main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .viewer {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .viewer-panels {
      display: grid;
      grid-template-columns: minmax(420px, 0.65fr) minmax(360px, 0.35fr);
      gap: 24px;
      padding: 24px 28px 12px;
      border-bottom: 1px solid var(--border);
      align-items: stretch;
      max-height: 650px;
    }
    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      min-height: 0;
      overflow: hidden;
    }
    .carousel-panel,
    .details-panel {
      min-height: 0;
      height: 100%;
    }
    .panel h2 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.04em;
    }
    .carousel-frame {
      flex: 1;
      position: relative;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      overflow: hidden;
    }
    .autoplay-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 10px;
      cursor: zoom-in;
    }
    .carousel-badge {
      display: none;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }
    .metric-card {
      background: var(--bg-panel);
      border-radius: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      text-align: center;
    }
    .metric-card .label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .metric-card .value {
      font-size: 20px;
      font-weight: 600;
    }
    .run-summary {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    .run-path {
      font-family: "SFMono-Regular", "Consolas", monospace;
      font-size: 12px;
      color: var(--muted);
      background: #0b0f18;
      padding: 8px 10px;
      border-radius: 6px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }
    .section-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .details-stack {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }
    .details-stack > div:last-child {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }
    .metrics-text {
      background: #0f131d;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      flex: 1;
      min-height: 100px;
      overflow-y: auto;
      font-family: "SFMono-Regular", "Consolas", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      margin: 0;
    }
    .nav-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .nav-buttons button {
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      cursor: pointer;
    }
    .comparison-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .autoplay-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    .circle-button {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: none;
      background: transparent;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      transition: all 0.2s ease;
    }
    .circle-button:hover:not(:disabled) {
      color: var(--text);
      background: rgba(255,255,255,0.1);
    }
    .circle-button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .circle-button svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }
    .circle-button .icon-pause {
      display: none;
    }
    .circle-button.playing .icon-play {
      display: none;
    }
    .circle-button.playing .icon-pause {
      display: block;
    }
    .autoplay-speed {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 13px;
      font-weight: 500;
      padding: 4px 18px 4px 8px;
      appearance: none;
      cursor: pointer;
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%), linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: right 6px center;
      background-size: 5px 5px;
      background-repeat: no-repeat;
      transition: color 0.2s ease;
    }
    .autoplay-speed:hover:not(:disabled) {
      color: var(--text);
    }
    .autoplay-speed:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .tabs {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 28px 28px;
    }
    .tab-buttons {
      display: flex;
      gap: 16px;
      margin-top: 16px;
      border-bottom: 1px solid var(--border);
    }
    .tab-buttons button {
      border: none;
      background: none;
      color: var(--muted);
      padding: 12px 4px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      font-size: 15px;
    }
    .tab-buttons button.active {
      color: var(--text);
      border-color: var(--accent);
    }
    .tab-panel {
      display: none;
      padding: 18px 0;
      flex: 1;
      overflow-y: auto;
    }
    .tab-panel.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    thead {
      position: sticky;
      top: 0;
      background: var(--bg-card);
    }
    th, td {
      border-bottom: 1px solid var(--border);
      padding: 8px;
      text-align: left;
    }
    .table-thumb {
      width: 64px;
      height: 40px;
      object-fit: cover;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: #090d13;
    }
    tbody tr {
      cursor: pointer;
    }
    tbody tr.selected {
      background: rgba(105, 169, 255, 0.12);
    }
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: 18px;
    }
    .charts-grid img,
    .montage-grid img {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #090d13;
    }
    .montage-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 14px;
    }
    .empty-state {
      padding: 18px;
      border-radius: 10px;
      background: var(--bg-card);
      border: 1px dashed var(--border);
      color: var(--muted);
      text-align: center;
    }
    .leaderboard-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--muted);
    }
    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      padding: 20px;
    }
    .lightbox.active {
      display: flex;
    }
    .lightbox img {
      max-width: 90vw;
      max-height: 85vh;
      border-radius: 12px;
      border: 2px solid var(--border);
    }
    @media (max-width: 1100px) {
      main {
        flex-direction: column;
      }
      .viewer-panels {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Federated Learning Gradient Inversion: Interactive Explorer</h1>
        <div class="key-finding" id="keyFinding"></div>
      </div>
      <div class="meta">
        <div id="buildDate"></div>
        <div id="runCounts"></div>
      </div>
    </header>
    <main>
      <section class="viewer">
        <div class="viewer-panels">
          <div class="panel carousel-panel" id="autoplayPanel">
            <div class="comparison-header">
              <h2>Reconstruction Preview</h2>
              <div class="autoplay-controls">
                <button id="autoplayToggle" class="circle-button" aria-label="Start autoplay" title="Start autoplay" aria-pressed="false">
                  <span class="sr-only">Start autoplay</span>
                  <svg class="icon-play" viewBox="0 0 24 24" role="presentation">
                    <polygon points="8,5 19,12 8,19" />
                  </svg>
                  <svg class="icon-pause" viewBox="0 0 24 24" role="presentation">
                    <rect x="7" y="5" width="3" height="14" />
                    <rect x="14" y="5" width="3" height="14" />
                  </svg>
                </button>
                <select id="autoplaySpeed" class="autoplay-speed" aria-label="Loop speed">
                  <option value="4000">Slow</option>
                  <option value="2000" selected>Medium</option>
                  <option value="1000">Fast</option>
                </select>
              </div>
            </div>
            <div class="carousel-frame">
              <img id="autoplayImage" class="autoplay-image" alt="Autoplay preview" />
              <div class="carousel-badge" id="autoplayStatus">Slide 0 / 0</div>
            </div>
          </div>
          <div class="panel details-panel" id="selectedPanel">
            <div class="comparison-header">
              <h2>Run details</h2>
              <div class="nav-buttons">
                <button id="prevBtn" title="Previous run (Arrow Left)">Prev</button>
                <button id="nextBtn" title="Next run (Arrow Right)">Next</button>
              </div>
            </div>
            <div class="run-summary" id="runSummary">No run selected.</div>
            <div class="metrics-grid" id="selectedMetrics"></div>
            <div class="details-stack">
              <div>
                <div class="section-label">Run path</div>
                <div class="run-path" id="runPath"></div>
              </div>
              <div>
                <div class="section-label">Metrics</div>
                <pre class="metrics-text" id="metricsText">Metrics file not available.</pre>
              </div>
            </div>
          </div>
        </div>
        <section class="tabs">
          <div class="tab-buttons">
            <button data-tab="leaderboards" class="active">Leaderboards</button>
            <button data-tab="distributions">Distributions</button>
            <button data-tab="ablations">Ablations</button>
            <button data-tab="montages">Montages</button>
          </div>
          <div id="tab-leaderboards" class="tab-panel active">
            <div class="leaderboard-controls">
              <div id="filteredCount"></div>
              <div>Click any row to load that run.</div>
            </div>
            <div class="table-wrapper">
              <table>
                <thead>
                  <tr>
                    <th data-sort="group">Group</th>
                    <th data-sort="method">Method</th>
                    <th data-sort="client">Client</th>
                    <th data-sort="psnr">PSNR</th>
                    <th data-sort="ssim">SSIM</th>
                    <th data-sort="lpips">LPIPS</th>
                    <th data-sort="labelmatch">LabelMatch</th>
                    <th>Image</th>
                  </tr>
                </thead>
                <tbody id="leaderboardBody"></tbody>
              </table>
            </div>
          </div>
          <div id="tab-distributions" class="tab-panel">
            <div class="charts-grid" id="distributionCharts"></div>
          </div>
          <div id="tab-ablations" class="tab-panel">
            <div class="charts-grid" id="ablationCharts"></div>
            <div id="ablationTable"></div>
          </div>
          <div id="tab-montages" class="tab-panel">
            <div class="montage-grid" id="montageGrid"></div>
            <div class="empty-state" id="montageEmpty" style="display:none;">
              No montages available. Provide montage PNGs in results/report/montages/.
            </div>
          </div>
        </section>
      </section>
    </main>
  </div>
  <div class="lightbox" id="lightbox">
    <img id="lightboxImg" alt="Full view" />
  </div>
  <script>
    const state = {
      data: null,
      placeholderImage: null,
      runsById: {},
      filters: {
        groups: new Set(),
        methods: new Set(),
        clients: new Set(),
      },
      search: "",
      sort: "best",
      selectedRunId: null,
      filteredIds: [],
      tableSort: { field: "psnr", dir: "desc" },
      autoplay: {
        playing: false,
        interval: 8000,
        timerId: null,
      },
    };

    const METRIC_FIELDS = ["PSNR", "SSIM", "LPIPS", "MSE", "LabelMatch"];
    const FILTER_HINTS = {
      groups: "Scenario group shown on the poster",
      methods: "Defense or method configuration",
      clients: "Client / participant identifier",
    };

    fetch("data.json")
      .then((res) => res.json())
      .then(initDashboard)
      .catch((err) => {
        console.error(err);
        document.body.innerHTML = "<pre style='padding:20px;color:#fff;'>Failed to load dashboard data.</pre>";
      });

    function initDashboard(data) {
      state.data = data;
      state.placeholderImage = data.placeholder_image || "";
      data.runs.forEach((run) => {
        state.runsById[run.run_id] = run;
      });
      populateFilters(data.filter_values);
      applyQueryParams();
      if (!state.selectedRunId) {
        state.selectedRunId = data.best_overall_id || (data.runs[0] && data.runs[0].run_id);
      }
      updateMeta(data.meta);
      wireEvents();
      populateCharts(data.charts);
      populateAblations(data.aggregates.ablations || []);
      populateMontages(data.montages || []);
      applyFilters();
      startAutoplay();
    }

    function populateFilters(values) {
      ["groups", "methods", "clients"].forEach((key) => {
        state.filters[key] = new Set(values[key]);
        const container = document.getElementById(`${key.slice(0, -1)}Filters`);
        if (!container) return;
        container.innerHTML = "";
        values[key].forEach((value) => {
          const btn = document.createElement("button");
          btn.className = "chip active";
          btn.textContent = value;
          btn.dataset.value = value;
          const hint = FILTER_HINTS[key] || "Filter option";
          btn.title = `${value} — ${hint}`;
          btn.addEventListener("click", () => toggleFilter(key, value, btn));
          container.appendChild(btn);
        });
      });
    }

    function applyQueryParams() {
      const params = new URLSearchParams(window.location.search);
      if (!params || Array.from(params.keys()).length === 0) {
        return;
      }
      const mapping = [
        { param: "group", key: "groups" },
        { param: "method", key: "methods" },
        { param: "client", key: "clients" },
      ];
      mapping.forEach(({ param, key }) => {
        if (!params.has(param)) return;
        const values = params
          .get(param)
          .split(",")
          .map((v) => v.trim())
          .filter(Boolean);
        if (values.length) {
          setFilterSet(key, values);
        }
      });
      if (params.has("search")) {
        const term = params.get("search");
        const searchInput = document.getElementById("searchInput");
        if (searchInput) searchInput.value = term;
        state.search = term.toLowerCase();
      }
      if (params.has("run_id")) {
        const runId = params.get("run_id");
        if (state.runsById[runId]) {
          state.selectedRunId = runId;
        }
      } else if (params.has("method") || params.has("client")) {
        const targetMethod = params.get("method");
        const targetClient = params.get("client");
        const candidate = state.data.runs.find((run) => {
          const methodMatch = !targetMethod || targetMethod.split(",").includes(run.method);
          const clientMatch = !targetClient || targetClient.split(",").includes(run.client);
          return methodMatch && clientMatch;
        });
        if (candidate) {
          state.selectedRunId = candidate.run_id;
        }
      }
    }

    function toggleFilter(key, value, btn) {
      const set = state.filters[key];
      if (set.has(value)) {
        set.delete(value);
        btn.classList.remove("active");
      } else {
        set.add(value);
        btn.classList.add("active");
      }
      if (set.size === 0) {
        setFilterSet(key, state.data.filter_values[key]);
        applyFilters();
        return;
      }
      applyFilters();
    }

    function updateMeta(meta) {
      document.getElementById("buildDate").textContent = `Build date: ${meta.build_time}`;
      const counts = Object.entries(meta.groups || {})
        .map(([group, count]) => `${group}: ${count}`)
        .join("  ·  ");
      document.getElementById("runCounts").textContent = `Total runs: ${meta.total_runs} (${counts})`;
      document.getElementById("keyFinding").textContent = meta.key_finding || "";
    }

    function wireEvents() {
      const searchInput = document.getElementById("searchInput");
      if (searchInput) {
        searchInput.addEventListener("input", (ev) => {
          state.search = ev.target.value.toLowerCase();
          applyFilters();
        });
      }
      const sortSelect = document.getElementById("sortSelect");
      if (sortSelect) {
        sortSelect.addEventListener("change", (ev) => {
          state.sort = ev.target.value;
          applyFilters();
        });
      }
      const btnBestOverall = document.getElementById("btnBestOverall");
      if (btnBestOverall) {
        btnBestOverall.addEventListener("click", () => {
          state.sort = "best";
          const sortSel = document.getElementById("sortSelect");
          if (sortSel) sortSel.value = "best";
          state.selectedRunId = state.data.best_overall_id;
          clearFilterSelections();
          applyFilters();
        });
      }
      const btnBaselineBest = document.getElementById("btnBaselineBest");
      if (btnBaselineBest) {
        btnBaselineBest.addEventListener("click", () => {
          focusOnMethod("baseline");
          const bestBaseline = state.data.best_baseline_id;
          if (bestBaseline) {
            state.selectedRunId = bestBaseline;
          }
          applyFilters();
        });
      }
      const btnBaselineWorst = document.getElementById("btnBaselineWorst");
      if (btnBaselineWorst) {
        btnBaselineWorst.addEventListener("click", () => {
          focusOnMethod("baseline");
          const baselineRuns = getRuns().filter((run) => run.method.toLowerCase().includes("baseline"));
          baselineRuns.sort((a, b) => worstSort(a, b));
          state.selectedRunId = baselineRuns[0] ? baselineRuns[0].run_id : state.selectedRunId;
          applyFilters();
        });
      }
      const btnDpSweep = document.getElementById("btnDpSweep");
      if (btnDpSweep) {
        btnDpSweep.addEventListener("click", () => {
          const dpMethods = state.data.filter_values.methods.filter((m) => m.toLowerCase().includes("dp"));
          setFilterSet("methods", dpMethods);
          applyFilters();
        });
      }
      document.getElementById("autoplayToggle").addEventListener("click", () => {
        if (state.autoplay.playing) {
          stopAutoplay();
        } else {
          startAutoplay();
        }
      });
      document.getElementById("autoplaySpeed").addEventListener("change", (ev) => {
        const value = Number(ev.target.value);
        if (!Number.isNaN(value)) {
          state.autoplay.interval = value;
          refreshAutoplayTimer();
        }
      });
      document.getElementById("prevBtn").addEventListener("click", () => jumpSelection(-1));
      document.getElementById("nextBtn").addEventListener("click", () => jumpSelection(1));
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "ArrowLeft") jumpSelection(-1);
        if (ev.key === "ArrowRight") jumpSelection(1);
      });
      document.querySelectorAll(".tab-buttons button").forEach((btn) => {
        btn.addEventListener("click", () => activateTab(btn.dataset.tab));
      });
      document.getElementById("lightbox").addEventListener("click", () => {
        document.getElementById("lightbox").classList.remove("active");
      });
      document.querySelectorAll("th[data-sort]").forEach((th) => {
        th.addEventListener("click", () => {
          const field = th.dataset.sort;
          const dir = state.tableSort.field === field && state.tableSort.dir === "desc" ? "asc" : "desc";
          state.tableSort = { field, dir };
          renderLeaderboards();
        });
      });
      const autoplayImg = document.getElementById("autoplayImage");
      if (autoplayImg) {
        autoplayImg.addEventListener("click", () => {
          const srcAttr = autoplayImg.getAttribute("src");
          if (srcAttr && srcAttr.trim()) {
            openLightbox(srcAttr);
          }
        });
      }
    }

    function clearFilterSelections() {
      ["groups", "methods", "clients"].forEach((key) => {
        setFilterSet(key, state.data.filter_values[key]);
      });
    }

    function focusOnMethod(name) {
      const target = state.data.filter_values.methods.filter((m) => m.toLowerCase().includes(name));
      if (target.length === 0) return;
      setFilterSet("methods", target);
    }

    function setFilterSet(key, values) {
      const allowed = state.data.filter_values[key] || [];
      const arrRaw = Array.isArray(values) ? values : Array.from(values || []);
      const filtered = arrRaw.filter((val) => allowed.includes(val));
      const arr = filtered.length ? filtered : allowed.slice();
      state.filters[key] = new Set(arr);
      const container = document.getElementById(`${key.slice(0, -1)}Filters`);
      if (!container) return;
      Array.from(container.children).forEach((chip) => {
        chip.classList.toggle("active", state.filters[key].has(chip.dataset.value));
      });
    }

    function getRuns() {
      return state.data.runs;
    }

    function applyFilters() {
      let runs = getRuns().slice();
      runs = runs.filter((run) => state.filters.groups.has(run.group));
      runs = runs.filter((run) => state.filters.methods.has(run.method));
      runs = runs.filter((run) => state.filters.clients.has(run.client));
      if (state.search) {
        runs = runs.filter((run) =>
          run.search_text && run.search_text.indexOf(state.search) !== -1
        );
      }
      runs.sort(sorterFor(state.sort));
      state.filteredIds = runs.map((run) => run.run_id);
      if (state.filteredIds.length === 0) {
        state.selectedRunId = null;
        stopAutoplay();
      } else if (!state.filteredIds.includes(state.selectedRunId)) {
        state.selectedRunId = state.filteredIds[0];
      }
      renderLeaderboards();
      renderSelectedRun();
      updateAutoplayControls();
    }

    function sorterFor(key) {
      switch (key) {
        case "psnr":
          return (a, b) => metricValue(b.metrics.PSNR, true) - metricValue(a.metrics.PSNR, true);
        case "ssim":
          return (a, b) => metricValue(b.metrics.SSIM, true) - metricValue(a.metrics.SSIM, true);
        case "lpips":
          return (a, b) => metricValue(a.metrics.LPIPS, false) - metricValue(b.metrics.LPIPS, false);
        case "labelmatch":
          return (a, b) => metricValue(b.metrics.LabelMatch, true) - metricValue(a.metrics.LabelMatch, true);
        case "path":
          return (a, b) => a.source_dir.localeCompare(b.source_dir);
        default:
          return (a, b) => bestSort(a, b);
      }
    }

    function bestSort(a, b) {
      const lp = metricValue(a.metrics.LPIPS, false) - metricValue(b.metrics.LPIPS, false);
      if (lp !== 0) return lp;
      const ssim = metricValue(b.metrics.SSIM, true) - metricValue(a.metrics.SSIM, true);
      if (ssim !== 0) return ssim;
      return metricValue(b.metrics.PSNR, true) - metricValue(a.metrics.PSNR, true);
    }

    function worstSort(a, b) {
      const lp = metricValue(b.metrics.LPIPS, false) - metricValue(a.metrics.LPIPS, false);
      if (lp !== 0) return lp;
      return metricValue(a.metrics.SSIM, true) - metricValue(b.metrics.SSIM, true);
    }

    function metricValue(value, preferHigher) {
      if (value === null || value === undefined || value === "") {
        return preferHigher ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      }
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return preferHigher ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      }
      return num;
    }

    function renderLeaderboards() {
      const tbody = document.getElementById("leaderboardBody");
      tbody.innerHTML = "";
      const filteredCountEl = document.getElementById("filteredCount");
      if (filteredCountEl) filteredCountEl.textContent = `${state.filteredIds.length} runs match filters`;
      const runs = state.filteredIds.map((id) => state.runsById[id]);
      runs.sort((a, b) => {
        const dir = state.tableSort.dir === "asc" ? 1 : -1;
        switch (state.tableSort.field) {
          case "group":
            return a.group.localeCompare(b.group) * dir;
          case "method":
            return a.method.localeCompare(b.method) * dir;
          case "client":
            return a.client.localeCompare(b.client) * dir;
          case "psnr":
            return (metricValue(a.metrics.PSNR, true) - metricValue(b.metrics.PSNR, true)) * dir;
          case "ssim":
            return (metricValue(a.metrics.SSIM, true) - metricValue(b.metrics.SSIM, true)) * dir;
          case "lpips":
            return (metricValue(a.metrics.LPIPS, false) - metricValue(b.metrics.LPIPS, false)) * dir;
          case "labelmatch":
            return (metricValue(a.metrics.LabelMatch, true) - metricValue(b.metrics.LabelMatch, true)) * dir;
          default:
            return 0;
        }
      });
      runs.forEach((run) => {
        const tr = document.createElement("tr");
        if (run.run_id === state.selectedRunId) {
          tr.classList.add("selected");
        }
        const thumbSrc = run.image_path || state.placeholderImage || "";
        tr.innerHTML = `
          <td>${run.group}</td>
          <td>${run.method}</td>
          <td>${run.client}</td>
          <td>${formatMetric(run.metrics.PSNR)}</td>
          <td>${formatMetric(run.metrics.SSIM)}</td>
          <td>${formatMetric(run.metrics.LPIPS)}</td>
          <td>${formatMetric(run.metrics.LabelMatch)}</td>
          <td><img src="${thumbSrc}" alt="preview ${run.run_id}" class="table-thumb" /></td>
        `;
        tr.addEventListener("click", () => {
          state.selectedRunId = run.run_id;
          renderSelectedRun();
          renderLeaderboards();
        });
        const thumb = tr.querySelector(".table-thumb");
        if (thumb) {
          thumb.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const attr = thumb.getAttribute("src");
            if (attr && attr.trim()) {
              openLightbox(attr);
            }
          });
        }
        tbody.appendChild(tr);
      });
    }

    function renderSelectedRun() {
      const run = state.runsById[state.selectedRunId];
      const summaryEl = document.getElementById("runSummary");
      const pathEl = document.getElementById("runPath");
      const metricsContainer = document.getElementById("selectedMetrics");
      const metricsBox = document.getElementById("metricsText");
      if (!run) {
        if (summaryEl) summaryEl.textContent = "No run selected.";
        if (pathEl) pathEl.textContent = "No run available.";
        if (metricsContainer) metricsContainer.innerHTML = "";
        if (metricsBox) {
          metricsBox.textContent = state.filteredIds.length
            ? "Select a run to view metrics."
            : "No runs match the current filters.";
        }
        updateUrlState();
        syncAutoplayDisplay();
        refreshAutoplayTimer();
        return;
      }
      if (summaryEl) {
        summaryEl.textContent = `${run.group} | ${run.method} | ${run.client}`;
      }
      if (pathEl) {
        pathEl.textContent = run.source_dir || "Path unavailable";
      }
      if (metricsContainer) {
        metricsContainer.innerHTML = "";
        ["PSNR", "SSIM", "LPIPS", "MSE", "LabelMatch"].forEach((metric) => {
          const div = document.createElement("div");
          div.className = "metric-card";
          div.innerHTML = `<div class="label">${metric}</div><div class="value">${formatMetric(run.metrics[metric])}</div>`;
          metricsContainer.appendChild(div);
        });
      }
      if (metricsBox) {
        metricsBox.textContent = "Loading metrics...";
      }
      loadMetricsText(run);
      updateUrlState();
      syncAutoplayDisplay();
      refreshAutoplayTimer();
    }

    function updateUrlState() {
      if (!window.history || !window.history.replaceState) return;
      const params = new URLSearchParams();
      if (state.selectedRunId) {
        params.set("run_id", state.selectedRunId);
      }
      const query = params.toString();
      const newUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
      window.history.replaceState({}, "", newUrl);
    }

    function formatMetric(value) {
      if (value === undefined || value === null || Number.isNaN(value)) {
        return "—";
      }
      if (Math.abs(value) >= 100) {
        return value.toFixed(1);
      }
      if (Math.abs(value) >= 10) {
        return value.toFixed(2);
      }
      return value.toFixed(3);
    }

    const metricsCache = {};
    function loadMetricsText(run) {
      const box = document.getElementById("metricsText");
      if (!box) return;
      if (!run.metrics_path) {
        box.textContent = "Metrics file not available for this run.";
        return;
      }
      if (metricsCache[run.metrics_path]) {
        box.textContent = metricsCache[run.metrics_path];
        return;
      }
      fetch(run.metrics_path)
        .then((res) => res.text())
        .then((text) => {
          metricsCache[run.metrics_path] = text;
          if (state.selectedRunId === run.run_id) {
            box.textContent = text;
          }
        })
        .catch(() => {
          if (state.selectedRunId === run.run_id) {
        box.textContent = "Failed to load metrics.";
          }
        });
    }





    function startAutoplay() {
      if (!state.filteredIds.length) return;
      state.autoplay.playing = true;
      refreshAutoplayTimer();
      updateAutoplayControls();
    }

    function stopAutoplay() {
      state.autoplay.playing = false;
      refreshAutoplayTimer();
      updateAutoplayControls();
    }

    function refreshAutoplayTimer() {
      if (state.autoplay.timerId) {
        clearTimeout(state.autoplay.timerId);
        state.autoplay.timerId = null;
      }
      if (state.autoplay.playing && state.filteredIds.length > 1) {
        state.autoplay.timerId = window.setTimeout(stepAutoplay, state.autoplay.interval);
      }
      updateAutoplayControls();
    }

    function stepAutoplay() {
      if (!state.filteredIds.length) {
        stopAutoplay();
        return;
      }
      const currentIdx = state.filteredIds.indexOf(state.selectedRunId);
      const nextIdx = currentIdx === -1 ? 0 : (currentIdx + 1) % state.filteredIds.length;
      state.selectedRunId = state.filteredIds[nextIdx];
      renderSelectedRun();
      renderLeaderboards();
    }

    function syncAutoplayDisplay() {
      const image = document.getElementById("autoplayImage");
      const status = document.getElementById("autoplayStatus");
      const run = state.runsById[state.selectedRunId];
      const fallback = state.placeholderImage || "";
      if (!run) {
        if (image) image.setAttribute("src", fallback);
        if (status) {
          status.textContent = state.filteredIds.length ? "Slide 0 / " + state.filteredIds.length : "No runs";
        }
        return;
      }
      const src = run.image_path || fallback;
      if (image) image.setAttribute("src", src);
      if (status) {
        const idx = state.filteredIds.indexOf(run.run_id);
        const total = state.filteredIds.length || 1;
        const position = idx >= 0 ? idx + 1 : 1;
        status.textContent = `Slide ${position} / ${total}`;
      }
    }

    function updateAutoplayControls() {
      const btn = document.getElementById("autoplayToggle");
      if (btn) {
        btn.disabled = state.filteredIds.length === 0;
        btn.classList.toggle("playing", state.autoplay.playing);
        const label = state.autoplay.playing ? "Pause autoplay" : "Start autoplay";
        btn.setAttribute("aria-label", label);
        btn.setAttribute("title", label);
        btn.setAttribute("aria-pressed", String(state.autoplay.playing));
        const sr = btn.querySelector(".sr-only");
        if (sr) {
          sr.textContent = label;
        }
      }
      const select = document.getElementById("autoplaySpeed");
      if (select) {
        select.disabled = state.filteredIds.length === 0;
      }
    }

    function jumpSelection(delta) {
      if (!state.filteredIds.length) return;
      const idx = state.filteredIds.indexOf(state.selectedRunId);
      if (idx === -1) return;
      const nextIdx = Math.min(Math.max(idx + delta, 0), state.filteredIds.length - 1);
      state.selectedRunId = state.filteredIds[nextIdx];
      renderSelectedRun();
      renderLeaderboards();
    }

    function activateTab(tabName) {
      document.querySelectorAll(".tab-buttons button").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      document.querySelectorAll(".tab-panel").forEach((panel) => {
        panel.classList.toggle("active", panel.id === `tab-${tabName}`);
      });
    }

    function populateCharts(charts) {
      const distContainer = document.getElementById("distributionCharts");
      distContainer.innerHTML = "";
      ["defenses_grouped_bars", "defenses_scatter_psnr_vs_lpips", "multiclient_boxplots"].forEach((key) => {
        const path = charts[key];
        const div = document.createElement("div");
        if (path) {
          div.innerHTML = `<div style="margin-bottom:8px;font-size:14px;color:var(--muted);">${key.replace(/_/g, " ")}</div><img src="${path}" alt="${key}" />`;
        } else {
          div.innerHTML = `<div class="empty-state">Chart ${key} unavailable.</div>`;
        }
        distContainer.appendChild(div);
      });
      const ablationContainer = document.getElementById("ablationCharts");
      ablationContainer.innerHTML = "";
      const ablationPath = charts["ablation_bars"];
      if (ablationPath) {
        const div = document.createElement("div");
        div.innerHTML = `<div style="margin-bottom:8px;font-size:14px;color:var(--muted);">Ablation summary</div><img src="${ablationPath}" alt="Ablation chart" />`;
        ablationContainer.appendChild(div);
      }
    }

    function populateAblations(rows) {
      const container = document.getElementById("ablationTable");
      if (!rows || rows.length === 0) {
        container.innerHTML = '<div class="empty-state">No ablation data.</div>';
        return;
      }
      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th>Method</th>
            <th>Client</th>
            <th>PSNR</th>
            <th>SSIM</th>
            <th>LPIPS</th>
          </tr>
        </thead>
      `;
      const tbody = document.createElement("tbody");
      rows.forEach((row) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.method}</td>
          <td>${row.client}</td>
          <td>${formatMetric(row.PSNR)}</td>
          <td>${formatMetric(row.SSIM)}</td>
          <td>${formatMetric(row.LPIPS)}</td>
        `;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      container.innerHTML = "";
      container.appendChild(table);
    }

    function populateMontages(montages) {
      const grid = document.getElementById("montageGrid");
      const empty = document.getElementById("montageEmpty");
      if (!montages || montages.length === 0) {
        grid.innerHTML = "";
        empty.style.display = "block";
        return;
      }
      empty.style.display = "none";
      grid.innerHTML = "";
      montages.forEach((item) => {
        const card = document.createElement("div");
        card.innerHTML = `<div style="margin-bottom:6px;color:var(--muted);">${item.name}</div>`;
        const img = document.createElement("img");
        img.src = item.path;
        img.alt = item.name;
        img.addEventListener("click", () => openLightbox(item.path));
        card.appendChild(img);
        grid.appendChild(card);
      });
    }

    function openLightbox(path) {
      const modal = document.getElementById("lightbox");
      document.getElementById("lightboxImg").src = path;
      modal.classList.add("active");
    }
  </script>
</body>
</html>